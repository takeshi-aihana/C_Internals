## 算術演算の翻訳

どのように計算式がアセンブリ言語のコードに「翻訳」されるのかを見ていくことにしましょう。
この C言語のコードを例にとります：

```C
        int a = 2;
        int b = 3;
        int c = 24;
        a = a + b;
        aa = a + b * c;
```

これが生成したアセンブリ言語のコードです：

```asm
	movl	$2, -4(%ebp)
	movl	$3, -8(%ebp)
	movl	$24, -12(%ebp)
	movl	-8(%ebp), %eax
	addl	%eax, -4(%ebp)
	movl	-8(%ebp), %eax
	imull	-12(%ebp), %eax
	addl	%eax, -4(%ebp)
```

スタックにおけるローカル変数の位置はそれぞれ次のとおりです（ローカル変数については[ここ](/ch03-01-stack-and-local-variables.md#スタックとローカル変数)で説明しました）：

```
    a => (ebp -  4) => -4(%ebp)
    b => (ebp -  8) => -8(%ebp)
    c => (ebp - 12) => -12(%ebp)
```

生成したアセンブリ言語のコードにコメントを入れたものが、こちらです：

```asm
# a = 2
	movl	$2, -4(%ebp)
# b = 3
	movl	$3, -8(%ebp)
# c = 24
	movl	$24, -12(%ebp)
# tmp = b
movl	-8(%ebp), %eax

（つづく）
```

i386 アーキテクチャには一つの命令に対して指定できるメモリ・アドレスの数に制限があります。
一個の命令で任意の数のメモリ・アドレスを使用することはできません。
そのため一時的な格納場所としてレジスタを使用します。
複数のレジスタを使って数値演算やその他の演算を行います。
レジスタの一般的な使い方は、最初にメモリの内容をレジスタに取り込み、レジスタ同士で何か操作してから、レジスタの値をメモリに格納するというものです。
次のサンプルでは、``eax`` レジスタを一時的な保管場所として使用しています。
上のコメントでは ``tmp`` が ``eax`` レジスタを表します。


```asm
(つづき）

# a = a + tmp
	addl	%eax, -4(%ebp)
# tmp = b
	movl	-8(%ebp), %eax
# tmp = tmp * c
	imull	-12(%ebp), %eax
# a = tmp + a
	addl	%eax, -4(%ebp)
```

**課題：**
算術式に"（）"が含まれている場合、どのようにアセンブリ言語のコードに翻訳されるのか？

---

* [目次](/SUMMARY.md#C言語インターナル)

* [前へ](/ch03-01-stack-and-local-variables.md#スタックとローカル変数)

* [次へ](/ch05-01-translation-of-bitdddwise-operations.md#ビット演算の翻訳)
